PDG的英文全称是procedural dependency graph（程序化依赖图表）。从名称可以看出，PDG是一种用于管理hda依赖的图表，这个图表和UE的蓝图很像

PDG的功能是什么呢？ 在生成游戏地形时，Houdini需要实现很多功能，包括：地形处理、生成道路、生成河流、生成植被等。我们不能把这些功能全部写到一个had中。如果把所有功能全部写到一个hda中，会有以下几个弊端：

1）had过于臃肿，hda里的连线将会错综复杂，不方便维护。

2）如果多个hda不是依赖关系，就可以并行烘焙，比如多线程并行烘焙，也可以多服务器并行烘焙，极大的提高了地形生成的速度。但是如果把所有功能都实现在一个had中，这个had就只能在单线程上顺序执行所有处理流程，极大降低了地形生成的效率。

3）如果将所有功能实现在同一个hda中，当我调整某个节点的参数时，会导致整个hda从头开始烘焙。但是如果我的houdini工程是由多个had组成，调整某个hda的参数，只会导致当前hda和依赖该hda的hda烘焙，这个hda之前的流程不需要重新烘焙。

如果把众多功能分别封装到不同的hda中，却没有管理这些hda之间依赖关系的机制，会给地形制作带来极大的不便。

比如我的程序化地形生成流程中包含以下几个功能模块：生成基础地表hda、生成道路hda、生成树木hda。要求树木不能生长在道路上。现在我用这3个hda生成一个“一条道路穿过树林”的场景。那么各hda执行的顺序就是，首先生成基础地表，然后生成道路，最后在不存在道路的地表上生成树木。如果没有三个hda依赖管理的机制，当我将道路移动到含有树木的区域，树木会和道路重合在一起，也就是树木生长在道路上。这时，我需要手动重新烘焙“生成树木hda”，这样，树木才能避开新的道路区域。如果一个工程包含的hda的数量十分庞大，各个hda之间的依赖关系错综复杂，是没有办法通过人力来管理其间的依赖关系的。

而PDG就是用来解决这样的问题，当我移动道路之后，“生成树木had”会自动重新烘焙。如下图，一片植被区域上放置一条道路。植被区域自动重新烘焙，清除了道路附近的植被。

另外，当道路被修改后，只有依赖道路的植被hda需要重新烘焙。道路之前的hda流程，比如生成基础地表hda则无需重新烘焙。

如果地形是分块制作，只有修改的道路所在地图块的植被会重新烘焙，其他地图块的植被不会重新烘焙。这极大提高了烘焙的效率。